unit analysisfiles; //поток анализа, поиска записей в ntfs

interface

uses
  Classes, Graphics, ExtCtrls, SysUtils, FileCtrl, windows, dialogs ,shellapi;

type  MFT_REF = Packed Record
    indexLow: dword;
    indexHigh: word;
    ordinal: word;
  end;
 type
PMFT_REF = ^MFT_REF;

type NTFS_VOLUME_CONTEXT=record
hvolume:	THANDLE;
sectorsize:	cardinal; // Двоичный логарифм длины сектора
clustersize:	cardinal; // Двоичный логарифм длины кластера
mft_begin:array[0..1] of 	DWORD;
mft_record_size:	DWORD; // Двоичный логарифм размера записи MFT
index_block_size:	DWORD; // Размер блока индекса в байтах
 mft_cache:	BYTE;
 indexdata:	BYTE;
UpCase:	WCHAR;
cacheline:array[0..1] of 	DWORD;
volumesize:	cardinal;
mft_fragments:	cardinal; // Количество фрагментов MFT
mft_fragment_lens:array[0..63] of  	DWORD;
mft_fragment_offsets:array[0..63] of 	DWORD;   // Считаем, что фрагментов MFT меньше 32
end;
  type clasters1= array [0..23] of  NTFS_VOLUME_CONTEXT ;
 type  pointer= array [0..25] of  NTFS_VOLUME_CONTEXT;
 type Tanalysisfiles = class(TThread)
 
  private

    exMFT_REF:MFT_REF  ; found:integer;

    { Private declarations }
  protected
    procedure Execute; override;
  public
    Procedure updateprogress;
    constructor Create();
    function StringToPWide(sStr: string; var iNewSize: integer): PWideChar;
  end;

implementation
uses  MainUnit;
//работа с библиотекой     ntfs.dll
 //f                   unction Get_MFT_EntryForPath (path : PWideChar; pathlen:Integer; var exMFT_REF: MFT_REF{PMFT_RECORD}) : DWord; stdcall; external 'ntfs.dll';
  function Get_MFT_EntryForPath (pcontext: pointer; path : PWideChar; var pathlen:Integer; var exMFT_REF: MFT_REF) : DWord; stdcall; external 'ntfs.dll';
  function GetFileClusters(context:NTFS_VOLUME_CONTEXT; fileref:MFT_REF; buflen:DWORD; lcn_len_pairs:clasters1):DWord; stdcall; external 'ntfs.dll';


 function Tanalysisfiles.StringToPWide(sStr: string; var iNewSize: integer): PWideChar;
var
  pw: PWideChar;
  iSize: integer;
begin
  iSize := Length(sStr) + 1;
  iNewSize := iSize * 2;

  pw := AllocMem(iNewSize);

  MultiByteToWideChar(CP_ACP, 0, PChar(sStr), iSize, pw, iNewSize);

  Result := pw;
end;

  constructor Tanalysisfiles.Create();
    begin
      inherited Create(False);
    end;

Procedure Tanalysisfiles.updateprogress;
begin
  MainUnit.MainForm.ProgressBar4.Position:=MainUnit.MainForm.ProgressBar4.Position+1;
end;

procedure Tanalysisfiles.Execute;
var

  s,	fmt :pwidechar;
  iSize: integer;
    context:pointer;
    inputlen:Integer; written :DWORD;
     letter :char;
     read,i,j:dword;
    clusters: clasters1;
begin
 MainForm.memo2.Clear;
 i:=0;
       while (not Terminated) and (i<length(mainform._maspath))  do
        begin
          s:=   StringToPWide(mainform._maspath[i],iSize);

          found:=Get_MFT_EntryForPath (context,s, inputlen, exMFT_REF);
          if found>0 then
          begin
         // letter:=s[0];
         read:=8;
           letter:=mainform._maspath[i][1];
   if (letter >= 'a') and  (letter <= 'z') then  letter :=Chr(Ord(letter) - 32);
          mainform.memo2.Lines.Add(mainform._maspath[i]+' '+inttostr(found)+' '+inttostr(exMFT_REF.indexLow)+' '+inttostr(exMFT_REF.indexHigh)+' '+inttostr(exMFT_REF.ordinal));
found := GetFileClusters(context[ord(letter)], exMFT_REF, read, clusters);

      written:= 0;
		  mainform.memo2.Lines.Add('File fragments:');
      j:=0;

			for  i:= 0 to read-1 do
      begin
   //     if (clusters[j + 1] = 0) then


	 //		fmt:= '%x%08x';

				mainform.memo2.Lines.Add('Start cluster : '+ inttostr(clusters[j + 1].mft_record_size));
		 //		WriteConsoleW(consoleOut, L", length: ", sizeof(L", length: ")/2-1, &written, 0);
		 //		buffer[written = wsprintfW(buffer, L"%08x\r\n", clusters[j + 2])] = 0;
		 //		WriteConsoleW(consoleOut, buffer, written, &written, 0);
		    end;


          end
          else      mainform.memo2.Lines.Add (mainform._maspath[i]+' '+'не найдено')  ;
          updateprogress;
          inc(i);
        end;
 mainform.flaganaliza:=false;
 mainform.ProgressBar4.Position:=0;

end;

{ TMoveThread }
end.

